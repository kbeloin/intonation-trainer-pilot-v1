{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nvar options = {\n  audioBitsPerSecond: 16000\n};\nvar chunks = [];\n\nconst useRecorder = () => {\n  _s();\n\n  const [audioURL, setAudioURL] = useState(\"\");\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder, setRecorder] = useState(null);\n  const [rawData, setRawData] = useState(null);\n  const ctx = new AudioContext();\n  const reader = new FileReader();\n  useEffect(() => {\n    // Lazily obtain recorder first time we're recording.\n    if (recorder === null) {\n      if (isRecording) {\n        requestRecorder().then(setRecorder, console.error);\n      }\n\n      return;\n    } // Manage recorder state.\n\n\n    if (isRecording) {\n      recorder.start();\n    } else {\n      recorder.stop();\n    } // Obtain the audio when ready.\n\n\n    const handleData = e => {\n      console.log(e.data); // const blob = new Blob([e.data]);\n\n      reader.readAsArrayBuffer(e.data);\n\n      reader.onloadend = () => {\n        ctx.decodeAudioData(reader.result).then(function (decodedData) {\n          const view = decodedData.getChannelData(0); //\n\n          console.log(decodedData);\n          setRawData(view); // This might be done by \n\n          setAudioURL(URL.createObjectURL(e.data)); //log of base64data is \"data:audio/ogg; codecs=opus;base64,GkX...\"\n        });\n      };\n    };\n\n    recorder.addEventListener(\"dataavailable\", handleData);\n    return () => recorder.removeEventListener(\"dataavailable\", handleData);\n  }, [recorder, isRecording]);\n\n  const startRecording = () => {\n    setIsRecording(true);\n  };\n\n  const stopRecording = () => {\n    setIsRecording(false);\n  };\n\n  return [audioURL, isRecording, startRecording, stopRecording, rawData];\n};\n\n_s(useRecorder, \"/t57FCeX2vt5NX2vpkjGLb89s9w=\");\n\nasync function requestRecorder() {\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: true\n  });\n  return new MediaRecorder(stream, options);\n}\n\nexport default useRecorder;","map":{"version":3,"sources":["/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/src/components/utils/useRecorder.js"],"names":["useEffect","useState","options","audioBitsPerSecond","chunks","useRecorder","audioURL","setAudioURL","isRecording","setIsRecording","recorder","setRecorder","rawData","setRawData","ctx","AudioContext","reader","FileReader","requestRecorder","then","console","error","start","stop","handleData","e","log","data","readAsArrayBuffer","onloadend","decodeAudioData","result","decodedData","view","getChannelData","URL","createObjectURL","addEventListener","removeEventListener","startRecording","stopRecording","stream","navigator","mediaDevices","getUserMedia","audio","MediaRecorder"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AAIA,IAAIC,OAAO,GAAG;AACZC,EAAAA,kBAAkB,EAAE;AADR,CAAd;AAIA,IAAIC,MAAM,GAAG,EAAb;;AAGA,MAAMC,WAAW,GAAG,MAAM;AAAA;;AACxB,QAAM,CAACC,QAAD,EAAWC,WAAX,IAA0BN,QAAQ,CAAC,EAAD,CAAxC;AACA,QAAM,CAACO,WAAD,EAAcC,cAAd,IAAgCR,QAAQ,CAAC,KAAD,CAA9C;AACA,QAAM,CAACS,QAAD,EAAWC,WAAX,IAA0BV,QAAQ,CAAC,IAAD,CAAxC;AACA,QAAM,CAACW,OAAD,EAAUC,UAAV,IAAwBZ,QAAQ,CAAC,IAAD,CAAtC;AACA,QAAMa,GAAG,GAAG,IAAIC,YAAJ,EAAZ;AACA,QAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;AAEAjB,EAAAA,SAAS,CAAC,MAAM;AACd;AACA,QAAIU,QAAQ,KAAK,IAAjB,EAAuB;AACrB,UAAIF,WAAJ,EAAiB;AACfU,QAAAA,eAAe,GAAGC,IAAlB,CAAuBR,WAAvB,EAAoCS,OAAO,CAACC,KAA5C;AACD;;AACD;AACD,KAPa,CASd;;;AACA,QAAIb,WAAJ,EAAiB;AACfE,MAAAA,QAAQ,CAACY,KAAT;AACD,KAFD,MAEO;AACLZ,MAAAA,QAAQ,CAACa,IAAT;AACD,KAda,CAgBd;;;AACA,UAAMC,UAAU,GAAGC,CAAC,IAAI;AACtBL,MAAAA,OAAO,CAACM,GAAR,CAAYD,CAAC,CAACE,IAAd,EADsB,CAEtB;;AAGAX,MAAAA,MAAM,CAACY,iBAAP,CAAyBH,CAAC,CAACE,IAA3B;;AACAX,MAAAA,MAAM,CAACa,SAAP,GAAmB,MAAM;AACvBf,QAAAA,GAAG,CAACgB,eAAJ,CAAoBd,MAAM,CAACe,MAA3B,EAAmCZ,IAAnC,CAAwC,UAASa,WAAT,EAAsB;AAC5D,gBAAMC,IAAI,GAAGD,WAAW,CAACE,cAAZ,CAA2B,CAA3B,CAAb,CAD4D,CACjB;;AAC3Cd,UAAAA,OAAO,CAACM,GAAR,CAAYM,WAAZ;AACAnB,UAAAA,UAAU,CAACoB,IAAD,CAAV,CAH4D,CAG1C;;AAClB1B,UAAAA,WAAW,CAAC4B,GAAG,CAACC,eAAJ,CAAoBX,CAAC,CAACE,IAAtB,CAAD,CAAX,CAJ4D,CAIpB;AAC1C,SALA;AAMH,OAPC;AAQD,KAdD;;AAgBAjB,IAAAA,QAAQ,CAAC2B,gBAAT,CAA0B,eAA1B,EAA2Cb,UAA3C;AACA,WAAO,MAAMd,QAAQ,CAAC4B,mBAAT,CAA6B,eAA7B,EAA8Cd,UAA9C,CAAb;AACD,GAnCQ,EAmCN,CAACd,QAAD,EAAWF,WAAX,CAnCM,CAAT;;AAqCA,QAAM+B,cAAc,GAAG,MAAM;AAC3B9B,IAAAA,cAAc,CAAC,IAAD,CAAd;AACD,GAFD;;AAIA,QAAM+B,aAAa,GAAG,MAAM;AAC1B/B,IAAAA,cAAc,CAAC,KAAD,CAAd;AACD,GAFD;;AAIA,SAAO,CAACH,QAAD,EAAWE,WAAX,EAAwB+B,cAAxB,EAAwCC,aAAxC,EAAuD5B,OAAvD,CAAP;AACD,CAtDD;;GAAMP,W;;AAwDN,eAAea,eAAf,GAAiC;AAC/B,QAAMuB,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAApC,CAArB;AACA,SAAO,IAAIC,aAAJ,CAAkBL,MAAlB,EAA0BvC,OAA1B,CAAP;AACD;;AACD,eAAeG,WAAf","sourcesContent":["import { useEffect, useState } from \"react\";\n\n\n\nvar options = {\n  audioBitsPerSecond: 16000\n}\n\nvar chunks = []\n\n\nconst useRecorder = () => {\n  const [audioURL, setAudioURL] = useState(\"\");\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder, setRecorder] = useState(null);\n  const [rawData, setRawData] = useState(null)\n  const ctx = new AudioContext()\n  const reader = new FileReader();\n\n  useEffect(() => {\n    // Lazily obtain recorder first time we're recording.\n    if (recorder === null) {\n      if (isRecording) {\n        requestRecorder().then(setRecorder, console.error);\n      }\n      return;\n    }\n\n    // Manage recorder state.\n    if (isRecording) {\n      recorder.start();\n    } else {\n      recorder.stop();\n    }\n\n    // Obtain the audio when ready.\n    const handleData = e => {\n      console.log(e.data)\n      // const blob = new Blob([e.data]);\n      \n\n      reader.readAsArrayBuffer(e.data);\n      reader.onloadend = () => {\n        ctx.decodeAudioData(reader.result).then(function(decodedData) {\n          const view = decodedData.getChannelData(0) //\n          console.log(decodedData)\n          setRawData(view); // This might be done by \n          setAudioURL(URL.createObjectURL(e.data))//log of base64data is \"data:audio/ogg; codecs=opus;base64,GkX...\"\n       });  \n    }\n    }; \n\n    recorder.addEventListener(\"dataavailable\", handleData);\n    return () => recorder.removeEventListener(\"dataavailable\", handleData);\n  }, [recorder, isRecording]);\n\n  const startRecording = () => {\n    setIsRecording(true);\n  };\n\n  const stopRecording = () => {\n    setIsRecording(false);\n  };\n\n  return [audioURL, isRecording, startRecording, stopRecording, rawData];\n};\n\nasync function requestRecorder() {\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n  return new MediaRecorder(stream, options);\n}\nexport default useRecorder;\n\n\n"]},"metadata":{},"sourceType":"module"}