{"ast":null,"code":"import _regeneratorRuntime from\"/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useState}from\"react\";var useRecorder=function useRecorder(){var _useState=useState(\"\"),_useState2=_slicedToArray(_useState,2),audioURL=_useState2[0],setAudioURL=_useState2[1];var _useState3=useState(false),_useState4=_slicedToArray(_useState3,2),isRecording=_useState4[0],setIsRecording=_useState4[1];var _useState5=useState(null),_useState6=_slicedToArray(_useState5,2),recorder=_useState6[0],setRecorder=_useState6[1];var _useState7=useState(null),_useState8=_slicedToArray(_useState7,2),rawData=_useState8[0],setRawData=_useState8[1];useEffect(function(){// Lazily obtain recorder first time we're recording.\nif(recorder===null){if(isRecording){requestRecorder().then(setRecorder,console.error);}return;}// Manage recorder state.\nif(isRecording){recorder.start();}else{recorder.stop();}// Obtain the audio when ready.\nvar handleData=function handleData(e){var arr=e.data;var reader=new FileReader();reader.addEventListener('loadend',function(){setRawData(reader.result);});reader.readAsArrayBuffer(arr);setAudioURL(URL.createObjectURL(e.data));// readyState will be 2\n};recorder.addEventListener(\"dataavailable\",handleData);return function(){return recorder.removeEventListener(\"dataavailable\",handleData);};},[recorder,isRecording]);var startRecording=function startRecording(){setIsRecording(true);};var stopRecording=function stopRecording(){setIsRecording(false);};return[audioURL,isRecording,startRecording,stopRecording,rawData];};function requestRecorder(){return _requestRecorder.apply(this,arguments);}function _requestRecorder(){_requestRecorder=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var stream;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return navigator.mediaDevices.getUserMedia({audio:true});case 2:stream=_context.sent;return _context.abrupt(\"return\",new MediaRecorder(stream));case 4:case\"end\":return _context.stop();}}},_callee);}));return _requestRecorder.apply(this,arguments);}export default useRecorder;","map":{"version":3,"sources":["/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/src/components/pages/useRecorder.js"],"names":["useEffect","useState","useRecorder","audioURL","setAudioURL","isRecording","setIsRecording","recorder","setRecorder","rawData","setRawData","requestRecorder","then","console","error","start","stop","handleData","e","arr","data","reader","FileReader","addEventListener","result","readAsArrayBuffer","URL","createObjectURL","removeEventListener","startRecording","stopRecording","navigator","mediaDevices","getUserMedia","audio","stream","MediaRecorder"],"mappings":"+hBAAA,OAASA,SAAT,CAAoBC,QAApB,KAAoC,OAApC,CAEA,GAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,EAAM,eACQD,QAAQ,CAAC,EAAD,CADhB,wCACjBE,QADiB,eACPC,WADO,8BAEcH,QAAQ,CAAC,KAAD,CAFtB,yCAEjBI,WAFiB,eAEJC,cAFI,8BAGQL,QAAQ,CAAC,IAAD,CAHhB,yCAGjBM,QAHiB,eAGPC,WAHO,8BAIMP,QAAQ,CAAC,IAAD,CAJd,yCAIjBQ,OAJiB,eAIRC,UAJQ,eAMxBV,SAAS,CAAC,UAAM,CACd;AACA,GAAIO,QAAQ,GAAK,IAAjB,CAAuB,CACrB,GAAIF,WAAJ,CAAiB,CACfM,eAAe,GAAGC,IAAlB,CAAuBJ,WAAvB,CAAoCK,OAAO,CAACC,KAA5C,EACD,CACD,OACD,CAED;AACA,GAAIT,WAAJ,CAAiB,CACfE,QAAQ,CAACQ,KAAT,GACD,CAFD,IAEO,CACLR,QAAQ,CAACS,IAAT,GACD,CAED;AACA,GAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAAAC,CAAC,CAAI,CACxB,GAAMC,CAAAA,GAAG,CAAGD,CAAC,CAACE,IAAd,CACA,GAAMC,CAAAA,MAAM,CAAG,GAAIC,CAAAA,UAAJ,EAAf,CACAD,MAAM,CAACE,gBAAP,CAAwB,SAAxB,CAAmC,UAAM,CACvCb,UAAU,CAACW,MAAM,CAACG,MAAR,CAAV,CACD,CAFD,EAIAH,MAAM,CAACI,iBAAP,CAAyBN,GAAzB,EACAf,WAAW,CAACsB,GAAG,CAACC,eAAJ,CAAoBT,CAAC,CAACE,IAAtB,CAAD,CAAX,CAA0C;AACzC,CATD,CAWAb,QAAQ,CAACgB,gBAAT,CAA0B,eAA1B,CAA2CN,UAA3C,EACA,MAAO,kBAAMV,CAAAA,QAAQ,CAACqB,mBAAT,CAA6B,eAA7B,CAA8CX,UAA9C,CAAN,EAAP,CACD,CA9BQ,CA8BN,CAACV,QAAD,CAAWF,WAAX,CA9BM,CAAT,CAgCA,GAAMwB,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,EAAM,CAC3BvB,cAAc,CAAC,IAAD,CAAd,CACD,CAFD,CAIA,GAAMwB,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,EAAM,CAC1BxB,cAAc,CAAC,KAAD,CAAd,CACD,CAFD,CAIA,MAAO,CAACH,QAAD,CAAWE,WAAX,CAAwBwB,cAAxB,CAAwCC,aAAxC,CAAuDrB,OAAvD,CAAP,CACD,CA/CD,C,QAiDeE,CAAAA,e,uJAAf,oKACuBoB,CAAAA,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC,CAAEC,KAAK,CAAE,IAAT,CAApC,CADvB,QACQC,MADR,+CAES,GAAIC,CAAAA,aAAJ,CAAkBD,MAAlB,CAFT,wD,kDAIA,cAAejC,CAAAA,WAAf","sourcesContent":["import { useEffect, useState } from \"react\";\n\nconst useRecorder = () => {\n  const [audioURL, setAudioURL] = useState(\"\");\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder, setRecorder] = useState(null);\n  const [rawData, setRawData] = useState(null)\n\n  useEffect(() => {\n    // Lazily obtain recorder first time we're recording.\n    if (recorder === null) {\n      if (isRecording) {\n        requestRecorder().then(setRecorder, console.error);\n      }\n      return;\n    }\n\n    // Manage recorder state.\n    if (isRecording) {\n      recorder.start();\n    } else {\n      recorder.stop();\n    }\n\n    // Obtain the audio when ready.\n    const handleData = e => {\n    const arr = e.data\n    const reader = new FileReader();\n    reader.addEventListener('loadend', () => {\n      setRawData(reader.result);\n    });\n\n    reader.readAsArrayBuffer(arr);\n    setAudioURL(URL.createObjectURL(e.data)); // readyState will be 2\n    };\n\n    recorder.addEventListener(\"dataavailable\", handleData);\n    return () => recorder.removeEventListener(\"dataavailable\", handleData);\n  }, [recorder, isRecording]);\n\n  const startRecording = () => {\n    setIsRecording(true);\n  };\n\n  const stopRecording = () => {\n    setIsRecording(false);\n  };\n\n  return [audioURL, isRecording, startRecording, stopRecording, rawData];\n};\n\nasync function requestRecorder() {\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n  return new MediaRecorder(stream);\n}\nexport default useRecorder;\n\n\n"]},"metadata":{},"sourceType":"module"}