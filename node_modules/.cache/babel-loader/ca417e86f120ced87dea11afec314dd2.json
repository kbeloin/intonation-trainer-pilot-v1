{"ast":null,"code":"import _regeneratorRuntime from\"/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useState}from\"react\";var options={audioBitsPerSecond:16000};var chunks=[];var useRecorder=function useRecorder(){var _useState=useState(\"\"),_useState2=_slicedToArray(_useState,2),audioURL=_useState2[0],setAudioURL=_useState2[1];var _useState3=useState(false),_useState4=_slicedToArray(_useState3,2),isRecording=_useState4[0],setIsRecording=_useState4[1];var _useState5=useState(null),_useState6=_slicedToArray(_useState5,2),recorder=_useState6[0],setRecorder=_useState6[1];var _useState7=useState(null),_useState8=_slicedToArray(_useState7,2),rawData=_useState8[0],setRawData=_useState8[1];useEffect(function(){// Lazily obtain recorder first time we're recording.\nif(recorder===null){if(isRecording){requestRecorder().then(setRecorder,console.error);}return;}// Manage recorder state.\nif(isRecording){recorder.start();}else{recorder.stop();}// Obtain the audio when ready.\nvar handleData=function handleData(e){var blob=new Blob([e.data],{'type':'audio/wav; base64'});var textPromise=blob.text();blob.text().then(function(text){setRawData(btoa(text));setAudioURL(URL.createObjectURL(e.data));});};// Trying to set the media type here so it matches with upload\n// readyState will be 2\nrecorder.addEventListener(\"dataavailable\",handleData);return function(){return recorder.removeEventListener(\"dataavailable\",handleData);};},[recorder,isRecording]);var startRecording=function startRecording(){setIsRecording(true);};var stopRecording=function stopRecording(){setIsRecording(false);};return[audioURL,isRecording,startRecording,stopRecording,rawData];};function requestRecorder(){return _requestRecorder.apply(this,arguments);}function _requestRecorder(){_requestRecorder=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var stream;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return navigator.mediaDevices.getUserMedia({audio:true});case 2:stream=_context.sent;return _context.abrupt(\"return\",new MediaRecorder(stream,options));case 4:case\"end\":return _context.stop();}}},_callee);}));return _requestRecorder.apply(this,arguments);}export default useRecorder;","map":{"version":3,"sources":["/Users/kylebeloin/Desktop/intonation_trainer/intonation_trainer/src/components/pages/useRecorder.js"],"names":["useEffect","useState","options","audioBitsPerSecond","chunks","useRecorder","audioURL","setAudioURL","isRecording","setIsRecording","recorder","setRecorder","rawData","setRawData","requestRecorder","then","console","error","start","stop","handleData","e","blob","Blob","data","textPromise","text","btoa","URL","createObjectURL","addEventListener","removeEventListener","startRecording","stopRecording","navigator","mediaDevices","getUserMedia","audio","stream","MediaRecorder"],"mappings":"+hBAAA,OAASA,SAAT,CAAoBC,QAApB,KAAoC,OAApC,CAGA,GAAIC,CAAAA,OAAO,CAAG,CACZC,kBAAkB,CAAE,KADR,CAAd,CAIA,GAAIC,CAAAA,MAAM,CAAG,EAAb,CAGA,GAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,EAAM,eACQJ,QAAQ,CAAC,EAAD,CADhB,wCACjBK,QADiB,eACPC,WADO,8BAEcN,QAAQ,CAAC,KAAD,CAFtB,yCAEjBO,WAFiB,eAEJC,cAFI,8BAGQR,QAAQ,CAAC,IAAD,CAHhB,yCAGjBS,QAHiB,eAGPC,WAHO,8BAIMV,QAAQ,CAAC,IAAD,CAJd,yCAIjBW,OAJiB,eAIRC,UAJQ,eAMxBb,SAAS,CAAC,UAAM,CACd;AACA,GAAIU,QAAQ,GAAK,IAAjB,CAAuB,CACrB,GAAIF,WAAJ,CAAiB,CACfM,eAAe,GAAGC,IAAlB,CAAuBJ,WAAvB,CAAoCK,OAAO,CAACC,KAA5C,EACD,CACD,OACD,CAED;AACA,GAAIT,WAAJ,CAAiB,CACfE,QAAQ,CAACQ,KAAT,GACD,CAFD,IAEO,CACLR,QAAQ,CAACS,IAAT,GACD,CAED;AACA,GAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAAAC,CAAC,CAAI,CACxB,GAAMC,CAAAA,IAAI,CAAG,GAAIC,CAAAA,IAAJ,CAAS,CAACF,CAAC,CAACG,IAAH,CAAT,CAAmB,CAAE,OAAS,mBAAX,CAAnB,CAAb,CAEA,GAAIC,CAAAA,WAAW,CAAGH,IAAI,CAACI,IAAL,EAAlB,CACAJ,IAAI,CAACI,IAAL,GAAYX,IAAZ,CAAiB,SAACW,IAAD,CAAU,CACzBb,UAAU,CAACc,IAAI,CAACD,IAAD,CAAL,CAAV,CACAnB,WAAW,CAACqB,GAAG,CAACC,eAAJ,CAAoBR,CAAC,CAACG,IAAtB,CAAD,CAAX,CAAyC,CAF3C,EAKC,CATD,CAWC;AAGD;AAEAd,QAAQ,CAACoB,gBAAT,CAA0B,eAA1B,CAA2CV,UAA3C,EACA,MAAO,kBAAMV,CAAAA,QAAQ,CAACqB,mBAAT,CAA6B,eAA7B,CAA8CX,UAA9C,CAAN,EAAP,CACD,CAnCQ,CAmCN,CAACV,QAAD,CAAWF,WAAX,CAnCM,CAAT,CAqCA,GAAMwB,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,EAAM,CAC3BvB,cAAc,CAAC,IAAD,CAAd,CACD,CAFD,CAIA,GAAMwB,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,EAAM,CAC1BxB,cAAc,CAAC,KAAD,CAAd,CACD,CAFD,CAIA,MAAO,CAACH,QAAD,CAAWE,WAAX,CAAwBwB,cAAxB,CAAwCC,aAAxC,CAAuDrB,OAAvD,CAAP,CACD,CApDD,C,QAsDeE,CAAAA,e,uJAAf,oKACuBoB,CAAAA,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC,CAAEC,KAAK,CAAE,IAAT,CAApC,CADvB,QACQC,MADR,+CAES,GAAIC,CAAAA,aAAJ,CAAkBD,MAAlB,CAA0BpC,OAA1B,CAFT,wD,kDAIA,cAAeG,CAAAA,WAAf","sourcesContent":["import { useEffect, useState } from \"react\";\n\n\nvar options = {\n  audioBitsPerSecond: 16000\n}\n\nvar chunks = []\n\n\nconst useRecorder = () => {\n  const [audioURL, setAudioURL] = useState(\"\");\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder, setRecorder] = useState(null);\n  const [rawData, setRawData] = useState(null)\n\n  useEffect(() => {\n    // Lazily obtain recorder first time we're recording.\n    if (recorder === null) {\n      if (isRecording) {\n        requestRecorder().then(setRecorder, console.error);\n      }\n      return;\n    }\n\n    // Manage recorder state.\n    if (isRecording) {\n      recorder.start();\n    } else {\n      recorder.stop();\n    }\n\n    // Obtain the audio when ready.\n    const handleData = e => {\n    const blob = new Blob([e.data], { 'type' : 'audio/wav; base64' });\n\n    var textPromise = blob.text();  \n    blob.text().then((text) => {\n      setRawData(btoa(text));\n      setAudioURL(URL.createObjectURL(e.data))}\n      )\n\n    }; \n      \n     // Trying to set the media type here so it matches with upload\n    \n    \n    // readyState will be 2\n\n    recorder.addEventListener(\"dataavailable\", handleData);\n    return () => recorder.removeEventListener(\"dataavailable\", handleData);\n  }, [recorder, isRecording]);\n\n  const startRecording = () => {\n    setIsRecording(true);\n  };\n\n  const stopRecording = () => {\n    setIsRecording(false);\n  };\n\n  return [audioURL, isRecording, startRecording, stopRecording, rawData];\n};\n\nasync function requestRecorder() {\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n  return new MediaRecorder(stream, options);\n}\nexport default useRecorder;\n\n\n"]},"metadata":{},"sourceType":"module"}